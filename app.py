# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q7P6QDxv6DShfeDselN0Biw1X4ypnsfS
"""

import streamlit as st
import pandas as pd
import gspread
from google.oauth2.service_account import Credentials
from datetime import datetime, timedelta
import json
import re
from typing import Dict, List, Any
import numpy as np

# Page config
st.set_page_config(page_title="Skylark Drone Coordinator", layout="wide")

# Custom CSS
st.markdown("""
    <style>
    .main-header { font-size: 3rem; color: #1f77b4; }
    .status-good { color: green; font-weight: bold; }
    .status-warning { color: orange; font-weight: bold; }
    .status-error { color: red; font-weight: bold; }
    </style>
""", unsafe_allow_html=True)

class DroneCoordinator:
    def __init__(self):
        self.setup_sheets()

    def setup_sheets(self):
        """Initialize Google Sheets connection"""
        SCOPE = [
            'https://www.googleapis.com/auth/spreadsheets',
            'https://www.googleapis.com/auth/drive'
        ]

        # For Streamlit Cloud, use secrets
        creds_dict = st.secrets.get("gcp_service_account", {})
        if creds_dict:
            creds = Credentials.from_service_account_info(creds_dict, scopes=SCOPE)
        else:
            st.error("Add Google Service Account to Streamlit Secrets")
            st.stop()

        self.client = gspread.authorize(creds)

        # Replace with YOUR sheet IDs
        self.SHEET_IDS = {
            'pilots': st.secrets.get("PILOT_SHEET_ID", "YOUR_PILOT_SHEET_ID"),
            'drones': st.secrets.get("DRONE_SHEET_ID", "YOUR_DRONE_SHEET_ID"),
            'missions': st.secrets.get("MISSION_SHEET_ID", "YOUR_MISSION_SHEET_ID")
        }

        self.pilot_sheet = self.client.open_by_key(self.SHEET_IDS['pilots']).sheet1
        self.drone_sheet = self.client.open_by_key(self.SHEET_IDS['drones']).sheet1
        self.mission_sheet = self.client.open_by_key(self.SHEET_IDS['missions']).sheet1

    def load_data(self, sheet_name: str) -> pd.DataFrame:
        """Load data from Google Sheet"""
        sheet = getattr(self, f"{sheet_name}_sheet")
        records = sheet.get_all_records()
        return pd.DataFrame(records)

    def update_pilot_status(self, name: str, status: str, assignment: str = "") -> bool:
        """Update pilot status in Google Sheet (2-way sync)"""
        df = self.load_data('pilot')
        row_idx = df[df['name'] == name].index[0] + 2  # +2 for header row

        self.pilot_sheet.update_cell(row_idx, 7, status)  # status column
        if assignment:
            self.pilot_sheet.update_cell(row_idx, 6, assignment)  # assignment column

        return True

    def calculate_pilot_cost(self, pilot_name: str, project_id: str) -> float:
        """Calculate total mission cost for pilot"""
        pilot_df = self.load_data('pilot')
        mission_df = self.load_data('mission')

        pilot = pilot_df[pilot_df['name'] == pilot_name].iloc[0]
        mission = mission_df[mission_df['project_id'] == project_id].iloc[0]

        start = pd.to_datetime(mission['start_date'])
        end = pd.to_datetime(mission['end_date'])
        hours = (end - start).days * 8  # 8hr workdays

        hourly_rate = float(pilot['hourly_rate']) if pilot['hourly_rate'] else 50
        return hours * hourly_rate * 1.2  # 20% overhead

    def find_pilot_matches(self, skills: str, location: str, budget: float) -> pd.DataFrame:
        """Find best pilot matches"""
        pilot_df = self.load_data('pilot')
        pilot_df = pilot_df[pilot_df['status'] == 'Available'].copy()

        # Skill matching
        pilot_df['skill_match'] = pilot_df['skills'].apply(
            lambda x: len(set(skills.lower().split(',')) & set(x.lower().split(',')))
        )

        # Location matching (simple string match)
        pilot_df['location_match'] = pilot_df['current_location'].str.contains(location, na=False)

        # Cost feasibility
        pilot_df['affordable'] = True  # Simplified for demo

        return pilot_df.sort_values(['skill_match', 'location_match'], ascending=False)

    def detect_conflicts(self, project_id: str, pilot_name: str = None, drone_id: str = None) -> List[str]:
        """Comprehensive conflict detection"""
        conflicts = []
        mission_df = self.load_data('mission')
        mission = mission_df[mission_df['project_id'] == project_id].iloc[0]

        # 1. Double-booking
        pilot_df = self.load_data('pilot')
        if pilot_name:
            pilot_assignments = pilot_df[(pilot_df['name'] == pilot_name) &
                                       (pilot_df['status'] != 'Available')]
            if len(pilot_assignments) > 0:
                conflicts.append("‚ùå PILOT DOUBLE-BOOKED")

        # 2. Skill mismatch
        if pilot_name:
            pilot = pilot_df[pilot_df['name'] == pilot_name].iloc[0]
            req_skills = set(mission['required_skills'].lower().split(','))
            pilot_skills = set(pilot['skills'].lower().split(','))
            if not req_skills.issubset(pilot_skills):
                conflicts.append("‚ùå SKILL MISMATCH")

        # 3. Budget overrun
        if pilot_name:
            cost = self.calculate_pilot_cost(pilot_name, project_id)
            if cost > float(mission['budget']):
                conflicts.append(f"üí∞ BUDGET OVERRUN: ${cost:.0f} > ${mission['budget']}")

        # 4. Weather compatibility (drone)
        if drone_id:
            drone_df = self.load_data('drone')
            drone = drone_df[drone_df['drone_id'] == drone_id].iloc[0]
            weather = mission['weather_forecast']
            if weather == 'Rainy' and 'IP20' in drone['weather_rating']:
                conflicts.append("üåßÔ∏è WEATHER RISK: Drone not waterproof")

        # 5. Maintenance issues
        if drone_id:
            drone_df = self.load_data('drone')
            drone = drone_df[drone_df['drone_id'] == drone_id].iloc[0]
            if drone['status'] == 'In Maintenance':
                conflicts.append("üîß DRONE IN MAINTENANCE")

        return conflicts

    def suggest_urgent_reassignment(self, project_id: str) -> str:
        """AI-powered urgent reassignment suggestions"""
        mission_df = self.load_data('mission')
        mission = mission_df[mission_df['project_id'] == project_id].iloc[0]

        matches = self.find_pilot_matches(
            mission['required_skills'],
            mission['location'],
            float(mission['budget'])
        )

        if len(matches) == 0:
            return "No suitable pilots available for urgent reassignment"

        top3 = matches.head(3)
        suggestions = []
        for idx, pilot in top3.iterrows():
            cost = self.calculate_pilot_cost(pilot['name'], project_id)
            suggestions.append(f"‚Ä¢ {pilot['name']} (${cost:.0f}, {pilot['skill_match']} skills match)")

        return f"üö® URGENT REASSIGNMENT OPTIONS:\n" + "\n".join(suggestions)

# Initialize app
@st.cache_data(ttl=300)  # Refresh every 5 mins
def init_app():
    return DroneCoordinator()

coordinator = init_app()

# Main UI
st.markdown('<h1 class="main-header">üöÅ Skylark Drone Operations Coordinator</h1>', unsafe_allow_html=True)

# Sidebar controls
with st.sidebar:
    st.header("üìä Quick Actions")

    if st.button("üîÑ Refresh Data"):
        st.cache_data.clear()
        st.rerun()

    st.header("üìà Status Overview")

    try:
        pilots = coordinator.load_data('pilot')
        drones = coordinator.load_data('drone')
        missions = coordinator.load_data('mission')

        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("Available Pilots",
                     len(pilots[pilots['status'] == 'Available']))
        with col2:
            st.metric("Available Drones",
                     len(drones[drones['status'] == 'Available']))
        with col3:
            st.metric("Active Missions", len(missions))
        with col4:
            conflicts = sum(len(coordinator.detect_conflicts(m['project_id']))
                          for _, m in missions.iterrows())
            st.metric("Conflicts", conflicts, delta=f"{conflicts} issues")

    except:
        st.error("‚ö†Ô∏è Setup Google Sheets first")

# Tabs for different operations
tab1, tab2, tab3, tab4 = st.tabs(["üí¨ Chat Agent", "üë®‚Äç‚úàÔ∏è Pilots", "üöÅ Drones", "üéØ Missions"])

with tab1:
    # Conversational Agent
    if "messages" not in st.session_state:
        st.session_state.messages = []

    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])

    if prompt := st.chat_input("Ask me to assign pilots, check conflicts, or reassign urgently..."):
        st.session_state.messages.append({"role": "user", "content": prompt})
        with st.chat_message("user"):
            st.markdown(prompt)

        with st.chat_message("ai"):
            # Process natural language commands
            response = process_command(coordinator, prompt.lower())
            st.markdown(response)
            st.session_state.messages.append({"role": "ai", "content": response})

with tab2:
    st.header("üë®‚Äç‚úàÔ∏è Pilot Roster Management")

    pilots = coordinator.load_data('pilot')

    # Search pilots
    col1, col2 = st.columns(2)
    with col1:
        skill = st.selectbox("Filter by skill",
                           ["All", "Surveying", "Mapping", "FPV", "Agriculture", "Inspection"])
    with col2:
        status_filter = st.selectbox("Status", ["All", "Available", "Assigned", "On Leave"])

    filtered = pilots.copy()
    if skill != "All":
        filtered = filtered[filtered['skills'].str.contains(skill, na=False)]
    if status_filter != "All":
        filtered = filtered[filtered['status'] == status_filter]

    st.dataframe(filtered, use_container_width=True)

    # Bulk actions
    if st.button("‚úÖ Mark Selected as Available"):
        # Implementation for bulk updates
        st.success("Bulk update feature - coming soon!")

with tab3:
    st.header("üöÅ Drone Inventory")
    drones = coordinator.load_data('drone')
    st.dataframe(drones, use_container_width=True)

with tab4:
    st.header("üéØ Mission Control")

    # Mission assignment demo
    st.subheader("Quick Assignment")
    col1, col2, col3 = st.columns(3)

    with col1:
        project_id = st.selectbox("Select Mission",
                                coordinator.load_data('mission')['project_id'].tolist())

    with col2:
        pilot_options = coordinator.load_data('pilot')[coordinator.load_data('pilot')['status'] == 'Available']['name'].tolist()
        selected_pilot = st.selectbox("Assign Pilot", [""] + pilot_options)

    with col3:
        drone_options = coordinator.load_data('drone')[coordinator.load_data('drone')['status'] == 'Available']['drone_id'].tolist()
        selected_drone = st.selectbox("Assign Drone", [""] + drone_options)

    if st.button("üöÄ ASSIGN TEAM") and selected_pilot and selected_drone:
        conflicts = coordinator.detect_conflicts(project_id, selected_pilot, selected_drone)

        if conflicts:
            for conflict in conflicts:
                st.markdown(f'<span class="status-error">{conflict}</span>', unsafe_allow_html=True)
        else:
            # Assign (demo - updates sheet in real implementation)
            coordinator.update_pilot_status(selected_pilot, "Assigned", project_id)
            st.markdown(f'<span class="status-good">‚úÖ Team assigned to {project_id}!</span>', unsafe_allow_html=True)
            st.rerun()

# Command processor for chat
def process_command(coordinator: DroneCoordinator, command: str) -> str:
    """Process natural language commands"""

    if "assign" in command or "match" in command:
        missions = coordinator.load_data('mission')
        project_id = missions['project_id'].iloc[0]  # Default first mission
        matches = coordinator.find_pilot_matches("Surveying", "Bengaluru", 5000)

        if len(matches) > 0:
            best_pilot = matches.iloc[0]
            cost = coordinator.calculate_pilot_cost(best_pilot['name'], project_id)
            conflicts = coordinator.detect_conflicts(project_id, best_pilot['name'])

            response = f"**Recommended Pilot:** {best_pilot['name']}\n"
            response += f"**Cost:** ${cost:.0f}\n"
            if conflicts:
                response += "**‚ö†Ô∏è Conflicts:** " + "; ".join(conflicts)
            else:
                response += "**‚úÖ Ready to assign!**"
            return response

    elif "urgent" in command or "reassign" in command:
        return coordinator.suggest_urgent_reassignment("Project-001")

    elif "conflicts" in command:
        return f"Found {len(coordinator.detect_conflicts('Project-001'))} conflicts in active missions"

    elif "available" in command:
        pilots = coordinator.load_data('pilot')
        available = pilots[pilots['status'] == 'Available']
        return f"**Available pilots:** {len(available)} ({', '.join(available['name'].tolist())})"

    else:
        return "I can help with: pilot assignments, conflict detection, urgent reassignments, or status checks!"

# Footer
st.markdown("---")
st.markdown("*Built for Skylark Drones | 2-way Google Sheets sync | Real-time conflict detection*")